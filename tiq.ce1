CE1{
  name=TIQ                      // Timeline Interleaver & Quantizer
  glyph=⧗                       // tick
  version=0.1
  intent=dirs↔branches reversible.superposition

  scope{
    host="."                    // aggregator repo (init if absent)
    dirs.depth=1                // only first-level subdirs
    ignore={".git",".venv","node_modules"}
  }

  verbs{
    superpose  = "dirs → branch-per-dir (no rewrite)"
    extract    = "branch → standalone repo at target"
    map        = "list branches + heads + passports"
    diff       = "compare histories: left..right"
  }

  flags{
    --include-non-git           // snapshot plain dirs as orphan branches
    --prefix=<path>             // snapshot under subpath
    --promote=preds             // auto-promotion predicates (content,cadence,size,host-moved)
    --timeout=<sec>             // no-op if unmet
  }

  passport{
    tag = § blake3(tree(branch))[:8] ":" crc16(meta)
    cadence = per-branch-touch
  }

  seed.dense{
    X = (D, B, P)
    D: dirs(host; depth=1 \ ignore)
    B: sanitize: D → branches
    P(b) = § blake3(tree(b))[:8] ":" crc16(meta(b))
    Φ: D → B is idempotent, reversible-on-trees
  }

  plan.superpose{
    ensure host clean
    for d in dirs(host; depth=1 \ ignore):
      b = sanitize(d)
      if is_git(d):
        assert clean(d)
        remote="tiq/"+b
        add_remote_once(host, remote, d)
        fetch(host, remote, "+refs/heads/*:refs/remotes/"+remote+"/*", tags=true)
        oid = resolve_oid(remote)
        update_ref_sbx(b, oid)
      else if --include-non-git:
        switch_orphan(host, b)
        stage_snapshot(host, d, prefix=--prefix)
        commit(host, "import "+b+" (snapshot)")
      emit passport(branch=b)
  }

  plan.extract{
    input: branch, target
    mkdir target; git init target
    git -C target pull host branch
    emit "⧗ extracted" branch "→" target
  }

  plan.map{
    table = list(refs=refs/heads/*){branch, head_short, date_short, §}
    state: STAGED(⧗) if sbx≠host; MATERIALIZED(✓) if equal
  }

  plan.diff{
    show git log --oneline left..right
  }

  invariants{
    idempotent(superpose; no changes)
    reversible(extract∘superpose)
    fast_forward_only            // monotone promotion
    no_history_rewrite
    deterministic_branch_names
    stable_passports
  }

  emergent{
    deterministic_convergence
    reversible_views
    functorial_mapping(D→B)
    minimal_churn_cadence
    diff_as_dynamics
  }

  tests{
    T1: fresh host + N repos → N branches; passports present
    T2: rerun superpose twice → no changes
    T3: dirty child repo → ✖ and host untouched
    T4: extract(superpose(dir)) reproduces repo (tree hash equal)
    T5: snapshot mode → 1-commit orphan branch
  }

  emit{
    report.table(dir|type|branch|head|§)
    stderr: "blocked by host divergence" on non-FF
    stderr glyphs: ⧗ step, ↷ fetch, ✓ ok, ✖ abort
  }
}